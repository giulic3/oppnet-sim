\documentclass[a4paper,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{graphicx}
\graphicspath{ {images/} }

\usepackage{geometry}
 \geometry{
 a4paper
 }

% settings

\linespread{1.1}
 \renewcommand{\labelitemi}{$\textendash$}

 \setlength{\parindent}{0ex}

\begin{document}

\author{Giulia Cantini}
\title{A Tandem Queueing Model for Delay Analysis in Disconnected Ad Hoc Networks\\
\vspace{0.5cm}
\Large{An Omnet++ simulation}}
\maketitle
\date

\tableofcontents

\section{Introduzione}
I tradizionali protocolli di routing \textit{store-and-forward}, che richiedono l'esistenza di un cammino
end-to-end che colleghi sorgente e destinazione, non possono essere utilizzati in reti
soggette a disconnessioni frequenti. Una soluzione che può risolvere questo problema è
sfruttare il movimento dei nodi della rete ed utilizzare il paradigma \textit{store-carry-and-forward}.

In tali reti, chiamate \textit{Delay Tolerant Networks} (DTN), il ritardo di trasmissione dei dati tra i nodi
può risultare elevato a causa delle disconnessioni.

Un importante fattore che le caratterizza è l'opportunità di contatto tra coppie di nodi.
Due nodi sono in contatto se si trovano entro il range di trasmissione l'uno dell'altro,
ovvero ad una distanza tale da consentire lo scambio di pacchetti.

Il modello sviluppato consiste di una rete opportunistica formata da un insieme di tre code
che collaborano tra loro per realizzare il meccanismo opportunistico.

Esso si basa sulle seguenti assunzioni:

\begin{enumerate}
  \item I contatti sono puramente opportunistici, ovvero non si ha nessuna conoscenza
  di quando questi avverranno (protocollo \textit{no-context});
  \item la distribuzione dei tempi di inter-contatto ha un primo e secondo momento
  finiti. (????)
  \item la trasmissione di un pacchetto potrebbe fallire in caso di tempo di contatto
  troppo breve, con esigenza di ritrasmissione;
  \item il nodo sorgente ha in arrivo un flusso di pacchetti;
  \item i nodi sorgente e destinazione sono fissi, mentre i nodi intermedi sono mobili e
  fungono da \textit{relay};
  \item il modello è basato su due code che sono servite in alternanza da un singolo server.
  Il server è autonomo e non c'è modo di controllarne il movimento.

\end{enumerate}

\section{Modello}
% metti figura 1 dell'articolo
\section{Implementazione}
% divisione del codice sorgente.. ecc.. come si è implementato ogni requisito del modello
- estensione del namespace queueing con classe OppQueue che riprende comportamento e variabili
della Queue, estendendoli ai fini del modello

\section{Analisi}
\subsection{Configurazione}

% STO USANDO R
% installare ggplot2 per i grafici
% lanciare l'interprete r e poi eseguire install.packages("ggplot2")
% all'inizio del file aggiungere la riga library("ggplot2")
% Python 2.x o Python 3.x
% Python package da installare
% sudo pip (pip3) install ipython jupyter
% sudo pip (pip3) install numpy pandas matplotlib
% sudo pip (pip3) install scipy pivottablejs

% cose utili per eseguire la simulazione (cmd line)
% per vedere quante run sono state configurate (es. se c'è un par che cambia)
$ ./oppnet-sim -u Cmdenv -x General -g
% eseguire la simulazione da riga di comando
$ ./oppnet-sim -m -n .:../../Scaricati/omnetpp-5.4/samples/queueinglib -l ../../Scaricati/omnetpp-5.4/samples/queueinglib/queueinglib omnetpp.ini
% eseguire una run specifica (es. la 0)
$ ./oppnet-sim blablabla -u Cmdenv -c General -r 0
% eseguirle tutte (ma se una crasha, crasha tutto)
$ ./oppnet-sim blablabla -u Cmdenv -c General % per l'interfaccia grafica usare Qtenv
% oppure usare opp_runall e lanciarne una per una (meglio per debugging) TODO

\subsection{Risultati}

\section{Conclusioni}

\section{Bibliografia}
% articolo originale
% tutorial omnet, user guide, simulation manual
% r for beginners

\end{document}
